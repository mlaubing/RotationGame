
==================== FINAL INTERFACE ====================
2016-11-24 09:34:20.7928119 UTC

interface main@main:Types 8001
  interface hash: 368940d49262e1c75148ab9bd52756ea
  ABI hash: 58a7d7dd0c5a160c637c8953897db9fa
  export-list hash: 15e491aef40515e11f5d19cbdb2a19b3
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 88eb42931724fffa0b2f80dad22b4219
  sig of: Nothing
  used TH splices: False
  where
exports:
  Types.createIndexMap
  Types.getCoordinates
  Types.Map{Types.Map n u}
  Types.Player{Types.Player xpos ypos}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:GHC.Base f4d51a1fd479b72cfcf1a3615a73ed18
import  -/  base-4.9.0.0:GHC.Show 0f4f1b56cc1a8e3bb102cea90130c72c
import  -/  base-4.9.0.0:Prelude eb1c3af8140de70083f65c44bbe8cb37
9e3457b827a229caa646bebb7080811c
  $fShowPlayer :: GHC.Show.Show Types.Player
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Player
                  Types.$fShowPlayer_$cshowsPrec
                  Types.$fShowPlayer_$cshow
                  Types.$fShowPlayer_$cshowList -}
9e3457b827a229caa646bebb7080811c
  $fShowPlayer1 ::
    Types.Player -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2, HasNoCafRefs,
     Unfolding: (\ (x :: Types.Player)
                   (s :: GHC.Base.String)[OneShot] ->
                 case x of ww { Types.Player ww1 ww2 ->
                 GHC.Base.++ @ GHC.Types.Char (Types.$w$cshow ww1 ww2) s }) -}
9e3457b827a229caa646bebb7080811c
  $fShowPlayer_$cshow :: Types.Player -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.Player) ->
                 case w of ww { Types.Player ww1 ww2 -> Types.$w$cshow ww1 ww2 }) -}
9e3457b827a229caa646bebb7080811c
  $fShowPlayer_$cshowList :: [Types.Player] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ls :: [Types.Player]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__ @ Types.Player Types.$fShowPlayer1 ls s) -}
9e3457b827a229caa646bebb7080811c
  $fShowPlayer_$cshowsPrec ::
    GHC.Types.Int -> Types.Player -> GHC.Show.ShowS
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,A><S,1*U(1*U(U),1*U(U))><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (x :: Types.Player)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n1 :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n1
                      (Types.$fShowPlayer_$cshow x))
                   s) -}
c14d3d2799f88462660a3953040129ac
  $tc'Map :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1258458796029239156L##
                   18000907264908706167L##
                   Types.$trModule
                   Types.$tc'Map1) -}
9e03f5f01414a3628de1b0a417444968
  $tc'Map1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Map"#) -}
901138ed19caf30deff9ab8458a62d79
  $tc'Player :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1915666090023517972L##
                   10837513317170704213L##
                   Types.$trModule
                   Types.$tc'Player1) -}
a7448f39ba2269a0ed981dba374ef169
  $tc'Player1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Player"#) -}
df49ac208f3aa473ea8c557fa71b9ddf
  $tcMap :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17929887623255777579L##
                   6166913329808273862L##
                   Types.$trModule
                   Types.$tcMap1) -}
4e9c4b0a310f43e0fd5679b04fbea939
  $tcMap1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Map"#) -}
21c895f3b53ef55152b8cb9782a2a925
  $tcPlayer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7802800962524019396L##
                   8413592643054504861L##
                   Types.$trModule
                   Types.$tcPlayer1) -}
93e4e78807da5e462561a8e1e8f8a5b3
  $tcPlayer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Player"#) -}
1a5292c41cfb76ffc12733c6e453f427
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Types.$trModule2 Types.$trModule1) -}
ba03922dd37c9f7d4792154d65ea10bd
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Types"#) -}
353d80ee02cc3bb30df29a319dceae2a
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
90452dbb6c402133d789b57c7ed13f7b
  $w$cshow :: GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int) (ww1 :: GHC.Types.Int) ->
                 GHC.CString.unpackAppendCString#
                   "x: "#
                   (case ww of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                      (GHC.CString.unpackAppendCString#
                         "\n\
                         \y: "#
                         (case ww1 of ww8 { GHC.Types.I# ww9 ->
                          case GHC.Show.$wshowSignedInt
                                 0#
                                 ww9
                                 (GHC.Types.[] @ GHC.Types.Char) of ww10 { (#,#) ww11 ww12 ->
                          GHC.Types.: @ GHC.Types.Char ww11 ww12 } })) } })) -}
f49ce615097db27408153ac661fe6fa4
  $wcreateIndexMap ::
    GHC.Types.Int -> GHC.Prim.Int# -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Types.Int) (ww1 :: GHC.Prim.Int#) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># 0# ww1) of wild {
                   GHC.Types.False
                   -> case ww of wild1 { GHC.Types.I# y ->
                      let {
                        lvl :: [GHC.Types.Int] = GHC.Enum.eftInt 0# y
                      } in
                      letrec {
                        go :: GHC.Prim.Int# -> [(GHC.Types.Int, GHC.Types.Int)]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ (x :: GHC.Prim.Int#) ->
                          let {
                            ds :: GHC.Types.Int {- Strictness: m -} = GHC.Types.I# x
                          } in
                          let {
                            z :: [(GHC.Types.Int, GHC.Types.Int)]
                            = case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.==# x ww1) of wild2 {
                                GHC.Types.False -> go (GHC.Prim.+# x 1#)
                                GHC.Types.True -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int) }
                          } in
                          letrec {
                            go1 :: [GHC.Types.Int] -> [(GHC.Types.Int, GHC.Types.Int)]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [GHC.Types.Int]) ->
                              case ds1 of wild2 {
                                [] -> z
                                : y1 ys
                                -> GHC.Types.: @ (GHC.Types.Int, GHC.Types.Int) (ds, y1) (go1 ys) }
                          } in
                          go1 lvl
                      } in
                      go 0# }
                   GHC.Types.True
                   -> GHC.Types.[] @ (GHC.Types.Int, GHC.Types.Int) }) -}
86436a0f20338218a98b767f98ed0b45
  data Map = Map {n :: GHC.Types.Int, u :: GHC.Types.Int}
9e3457b827a229caa646bebb7080811c
  data Player = Player {xpos :: GHC.Types.Int, ypos :: GHC.Types.Int}
6a688d4ec91fbf40dbbff100ee887a55
  createIndexMap :: Types.Map -> [(GHC.Types.Int, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(S)),1*U(1*U(U),1*U(U))>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.Map) ->
                 case w of ww { Types.Map ww1 ww2 ->
                 case ww2 of ww3 { GHC.Types.I# ww4 ->
                 Types.$wcreateIndexMap ww1 ww4 } }) -}
3ca03f27bb1997e2fc86b980f579c1d2
  getCoordinates :: Types.Player -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Player) ->
                 case ds of wild { Types.Player ds1 ds2 -> (ds1, ds2) }) -}
c967fbd6ae7676a785c091ea69fb7bc7
  n :: Types.Map -> GHC.Types.Int
  RecSel Left Types.Map
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Map) ->
                 case ds of wild { Types.Map ds1 ds2 -> ds1 }) -}
ec89c1fbc31cc4be8fb88069a13cd283
  u :: Types.Map -> GHC.Types.Int
  RecSel Left Types.Map
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Map) ->
                 case ds of wild { Types.Map ds1 ds2 -> ds2 }) -}
b39a93785c2b398d3e6f060b079ea83a
  xpos :: Types.Player -> GHC.Types.Int
  RecSel Left Types.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Player) ->
                 case ds of wild { Types.Player ds1 ds2 -> ds1 }) -}
ffe6f405acc71abec26bf19737e3807b
  ypos :: Types.Player -> GHC.Types.Int
  RecSel Left Types.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.Player) ->
                 case ds of wild { Types.Player ds1 ds2 -> ds2 }) -}
instance [safe] GHC.Show.Show [Types.Player] = Types.$fShowPlayer
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

